Shop2工程的更新日志

2.0版本：截止2017年5月30日完成---
	该版本完成了数据库操作模块、HTTP请求映射模块、持久化依赖注入容器模块
	1）数据库操作由泛型反射注解完成，model包内存放的是和数据表对应的各个数据模型类，
		Util包中的DbUtil类完成了C3P0数据库连接的获取，在此基础上，DataBase类完成了数据库占位符操作的简单封装
		console.dao包是数据库操作的核心包，模块向外开放Dao接口，实现的类主要是DaoImpl，
		其内部用泛型替代model类，利用反射去调用model类内部的set、get方法，且自定义model类注解和字段注解，
		通过反射其注解抽象操作，实现基本的增删改查等功能。
		console.biz包是对dao包的高层调用，是数据库操作模块开放给业务逻辑层的接口，其实现了各个数据表所对应的各种操作
		简化了业务逻辑中对数据库的访问的代码量
	2） HTTP请求映射层主要是规定了项目的URL的含义http:ip:port/项目名/{{servlet}}/{{controller}}/{{action}}
		同样是通过反射和注解来映射到对应的controller的action中，这里就不详细介绍了
	3）持久化的依赖注入容器是通过容器类的单例模式实现的，容器内部存放了两个Map，分别是从Xml中读取的配置信息的存储
		和实际的配置对象的存储，由于容器类本身实现单例模式，可以保证两个Map的唯一性，而项目开始之初就解析Xml配置来初始化
		配置信息的Map，在实际调用配置的对象的过程中，首次调用会在配置信息Map中读取配置信息反射初始化对象，然后存到对象Map中
		这样既保证了对象的唯一性提高内存使用效率和初始化的效率，而且不需要再初始化过程中再去初始化过多的对象，而是以注入形式
		直接把值或者容器内存放的其他对象注入到当前对象中。
	以上三者分别是效仿Hibernate、SpringMVC、Spring的。
	但是目前为止还有一些细节上面的问题，这个项目会一直维护下去，之后的修改更新日志会记录在note.txt中。

2.1版本
	解决2.0中的问题：
	1）dao在save的过程中没有能把model的id取得，使得业务逻辑显得有点复杂
		解决方案：
		在save操作最后根据用于插入的所有参数再去做一次根据id递减的查询
	2) context.xml在项目中的位置过于定死，而且所有的bean都必须写在内部
		解决方案：
		parseXml多了一个文件路径的参数，文件路径由调用方去规定，且循环遍历所有的import节点，以此来开放配置文件的填写目录
	3）导入log4j，支持日志打印
	4) http请求的返回模式单一
		解决方案，在action的注解中加上两个参数，来区分几种不同的返回
		现在已经添加了JSON、XML、FORWARD、REDIRECT几种返回方式（后两种尚未测试）

2.2版本
	这个版本需要对整个数据库连接层面做出极大的扩张
	首先主键要脱离id的约束
	其次要增加外键约束的便捷存取	
	利用一系列复杂的递归处理，基本已经完成了外键约束的便捷操作
	但是目前来讲还有几个弊端：
	1）局限性太强，完全竖立在主键在model中的变量名为id且为int型的情况下，在此项目中可行却不具有很强的可移植性，
		作为当前项目的框架勉强可行，但是作为自开发开源框架局限性太强
	2）为了让数据库模块和容器模块降低耦合，在数据库的递归调用时并没有直接去容器里获取可用的dao，而是新建一个dao
		这样数据库的存取效率将会大幅度降低，这点的解决方案大致拟化如下，将query中调用本类的clazz和newInstance的做法改为传参形式，
		而query则不具有只对当前dao对应的model的存取的局限性，然后上层对query封装使得其再次具有当前model操作的能力
		而中间多出的不具有局限性的query函数虽然不对外开放，却可以用作内部递归调用使用，这样不需要每次去创建新的dao
		但是这种方案对原有架构的改变较大，暂时不做改变，先记一笔，以后大幅度改动代码时再做这两个弊端的更新
	此外给下次大幅度改写提供一个有效的方案，由于目前代码在功能强化的过程中越来越乱，而乱的根本原因之一是反射机制代码的重复累赘
	因此下次大幅度改写时建议先写一个功能强大的ModelUtil模块，完成所有反射机制的功能实现。	
	
		